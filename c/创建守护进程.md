# 编写守护进程程序的要点：

1. 让程序在后台执行。方法是调用fork（）产生一个子进程，然后使父进程退出。

2. 调用setsid（）创建一个新对话期。控制终端、登录会话和进程组通常是从父进程继承下来的，守护进程要摆脱它们，不受它们的影响，方法是调用setsid（）使进程成为一个会话组长。setsid（）调用成功后，进程成为新的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。

3. 禁止进程重新打开控制终端。经过以上步骤，进程已经成为一个无终端的会话组长，但是它可以重新申请打开一个终端。为了避免这种情况发生，可以通过使进程不再是会话组长来实现。再一次通过fork（）创建新的子进程，使调用fork的进程退出。

4. 关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。首先获得最高文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值的所有文件描述符。

5. 将当前目录更改为根目录。

6. 子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为防止这一点，使用unmask（0）将屏蔽字清零。

7. 处理SIGCHLD信号。对于服务器进程，在请求到来时往往生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie），从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。这样，子进程结束时不会产生僵尸进程。

# 用函数daemon函数创建守护进程
linux提供了 daemon()函数主要用于希望脱离控制台，以守护进程形式在后台运行的程序
原型：
> #include<unistd.h>  
> intdaemon(intnochdir,intnoclose);

参数：
> 当nochdir为0时，daemon将更改进城的根目录为root(“/”)。  
> 当noclose为0是，daemon将进城的STDIN, STDOUT, STDERR都重定向到/dev/null。

返回值：
> deamon()调用了fork()，如果fork成功，那么父进程就调用_exit(2)退出，所以看到的错误信息 全部是子进程产生的。如果成功函数返回0，否则返回-1并设置errno。
